// Generated by CoffeeScript 2.5.1
// Output.coffee
var strStdSymbols, utilsPath;

import fs from 'fs';

import {
  strict as assert
} from 'assert';

import pathlib from 'path';

import Mustache from 'mustache';

import {
  config
} from './starbucks.config.js';

import {
  sep_dash,
  dumpOutput,
  isString,
  error,
  say,
  undef,
  words,
  stringToArray,
  unitTesting
} from '@jdeighan/coffee-utils';

import {
  indentedBlock,
  indentedStr
} from '@jdeighan/coffee-utils/indent';

import {
  brewCoffee
} from './brewCoffee.js';

// --- disable all escaping in Mustache
Mustache.escape = function(text) {
  return text;
};

// ---------------------------------------------------------------------------
//    exporting variable stdImportStr simplifies unit testing
utilsPath = `${config.libDir}/coffee_utils.js`;

strStdSymbols = words("undef say ask isEmpty nonEmpty").join(',');

export var stdImportStr = `import {${strStdSymbols}} from '${utilsPath}';`;

// ---------------------------------------------------------------------------
export var Output = class Output {
  constructor(filename1 = 'unit test', logger = undef) {
    this.filename = filename1;
    this.logging = logger != null;
    // --- We always want to set a logger, even if logging is false
    //     because logging could be turned on at any point
    this.logger = logger || console.log;
    if (!this.logger instanceof Function) {
      error("logger is not a function");
    }
    // --- if desired, this must be set using method doDump()
    this.dumping = false;
    this.hConsts = {
      FILE: this.filename
    };
    this.lLines = [];
  }

  // --- set a constant
  setConst(name, val) {
    this.hConsts[name] = val.toString();
  }

  // --- turn logging on or off
  doLog(flag, logger = void 0) {
    this.logging = flag;
    if (flag) {
      if (logger != null) {
        this.logger = logger;
      }
      this.log(sep_dash, this.filename, sep_dash);
    }
  }

  // --- turn dumping on or off
  doDump(flag) {
    this.dumping = flag;
  }

  put(line, level = 0) {
    this.lLines.push(indentedStr(line, level));
  }

  get() {
    return this.lLines.join('\n') + '\n';
  }

  getLines() {
    return this.lLines;
  }

  // --- log something
  log(...lArgs) {
    var arg, i, len;
    if (this.logging && this.logger) {
      for (i = 0, len = lArgs.length; i < len; i++) {
        arg = lArgs[i];
        this.logger(arg);
      }
    }
  }

};

// ---------------------------------------------------------------------------
export var StarbucksOutput = class StarbucksOutput extends Output {
  constructor(filename = 'unit test', logger = undef) {
    super(filename, logger);
    this.lPreStartup = [];
    this.lPreHtml = [];
    this.lPreScript = [];
    this.lStartup = [];
    this.lHtml = [];
    this.lScript = [];
    this.lStyle = [];
    this.lComponents = [];
    this.lVars = [];
  }

  // --- add a line of text to one of the
  //     output arrays
  hasSection(section) {
    switch (section) {
      case 'html':
        return this.lHtml.length > 0;
      case 'startup':
        return this.lStartup.length > 0;
      case 'script':
        return this.lScript.length > 0;
      case 'style':
        return this.lStyle.length > 0;
      default:
        return error(`Invalid section: ${section}`);
    }
  }

  // --- declare a found component
  //     results in 'import <name> from <componentsDir>/<name>.svelte;'

    // TODO: search for file <name>.svelte or <name>.starbucks
  addComponent(name) {
    var dir, path;
    if (this.lComponents.includes(name)) {
      return;
    }
    this.log(`   Component ${name} found`);
    dir = config.componentsDir;
    path = `${dir}/${name}.starbucks`;
    // --- Check if file exists, unless we're unit testing
    if (!unitTesting) {
      if (!fs.existsSync(path)) {
        path = `${dir}/${name}.svelte`;
        if (!fs.existsSync(path)) {
          path = pathlib.resolve(path);
          error(`No such component: ${name} in ${dir}`);
        }
      }
    }
    this.preScript(`import ${name} from '${path}';`);
    return this.lComponents.push(name);
  }

  addVar(name) {
    if (this.lVars.includes(name)) {
      return;
    }
    this.log(`   JS Variable ${name} found`);
    return this.lVars.push(name);
  }

  _addToSection(lSection, text, level = 0) {
    text = Mustache.render(text, this.hConsts);
    lSection.push(indentedBlock(text, level));
  }

  put(line, level = 0) {
    this._addToSection(this.lHtml, line, level);
  }

  putScript(text, level = 0) {
    this._addToSection(this.lScript, text, level);
  }

  // --- set a JavaScript variable
  //     for now, only support strings
  putJSVar(name, text, level = 0) {
    assert(isString(text));
    this.putScript(`${name} = \"\"\"`, level);
    this.putScript(text, level + 2);
    this.putScript("\"\"\"", level + 2);
  }

  putStartup(line, level = 0) {
    this._addToSection(this.lStartup, line, level);
  }

  putStyle(line, level = 0) {
    this._addToSection(this.lStyle, line, level);
  }

  preHtml(line, level = 0) {
    this._addToSection(this.lPreHtml, line, level);
  }

  preScript(line, level = 1) {
    this._addToSection(this.lPreScript, line, level);
  }

  preStartup(line, level = 1) {
    this._addToSection(this.lPreStartup, line, level);
  }

  get() {
    var i, lParts, len, name, ref, str, strFinal, strHtml, strPreHtml, strPreScript, strPreStartup, strScript, strStartup, strStyle;
    if (this.filename === 'index.starbucks') {
      say("get() from index.starbucks");
      say(this);
    }
    // --- This becomes an array of parts, which will
    //     be joined at the end
    lParts = [];
    strPreStartup = this.lPreStartup.join('\n');
    strStartup = this.lStartup.join('\n');
    if (strPreStartup || strStartup) {
      lParts.push('<script context="module">');
      lParts.push(brewCoffee(strStartup, strPreStartup));
      lParts.push('</script>', '');
    }
    strPreHtml = this.lPreHtml.join('\n');
    strHtml = this.lHtml.join('\n');
    if (strPreHtml || strHtml) {
      if (strPreHtml) {
        lParts.push(strPreHtml);
      }
      if (strHtml) {
        lParts.push(strHtml);
      }
    }
    strPreScript = this.lPreScript.join('\n');
    strScript = this.lScript.join('\n');
    if (strPreScript || strScript || (this.lVars.length > 0)) {
      lParts.push('', '<script>');
      // --- import standard symbols
      lParts.push(indentedStr(stdImportStr, 1));
      if (this.lVars.length > 0) {
        ref = this.lVars;
        // --- set all variables to undefined
        for (i = 0, len = ref.length; i < len; i++) {
          name = ref[i];
          str = `var ${name} = undef;`;
          lParts.push(indentedStr(str, 1));
        }
      }
      lParts.push(brewCoffee(strScript, strPreScript));
      lParts.push('</script>', '');
    }
    strStyle = this.lStyle.join('\n');
    if (strStyle) {
      lParts.push('', '<style>');
      lParts.push(strStyle);
      lParts.push('</style>', '');
    }
    strFinal = lParts.join('\n');
    if (this.dumping) {
      dumpOutput(strFinal, `FINAL OUTPUT for ${this.filename}:`);
    }
    return strFinal;
  }

  getLines() {
    return stringToArray(this.get());
  }

};
