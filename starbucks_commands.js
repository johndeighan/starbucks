// Generated by CoffeeScript 2.5.1
// starbucks_commands.coffee
var allow, atLevel, endCmd, hTransitions, isTrueCmd, nextState;

import {
  strict as assert
} from 'assert';

import {
  config
} from './starbucks.config.js';

import {
  error,
  undef,
  say,
  pass,
  stringToArray,
  truncateBlock,
  unitTesting,
  debug,
  debugging
} from '@jdeighan/coffee-utils';

import {
  indentedBlock,
  indentedStr
} from '@jdeighan/coffee-utils/indent';

import {
  StarbucksOutput,
  Output
} from './Output.js';

import {
  markdownify,
  markdownifyFile
} from './markdownify.js';

import {
  svelteEsc
} from './svelte_utils.js';

// ---------------------------------------------------------------------------
// Entries on the command stack have:
//       {
//          cmd:   <cmdName>,
//          state: <cmdState>,
//          level: <level>,
//          }
//    where <cmdState> is an integer

// --- Export, to allow unit testing
export var lCmdStack = [];

// --- utility methods
lCmdStack.empty = function() {
  return this.length === 0;
};

lCmdStack.nonempty = function() {
  return this.length > 0;
};

lCmdStack.TOS = function() {
  if (this.nonempty()) {
    return this[this.length - 1];
  } else {
    return undef;
  }
};

lCmdStack.dump = function() {
  var h, pos;
  if (lCmdStack.nonempty()) {
    say("   STACK:");
    pos = lCmdStack.length;
    while (pos > 0) {
      pos -= 1;
      h = lCmdStack[pos];
      say(`      cmd=${h.cmd} state=${h.state} level=${h.level}`);
    }
  } else {
    say("   STACK: empty");
  }
};

// ---------------------------------------------------------------------------
// 1. Ends all commands at a higher level than 'level'
// 2. Throws an error if this command isn't allowed here
// 3. May return text to be inserted
export var foundCmd = function(cmd, argstr, level, oOut) {
  var cur, next;
  if (!(oOut instanceof Output)) {
    error("foundCmd(): oOut not instance of Output");
  }
  debug(`DEBUG: foundCmd('${cmd}','${argstr}',${level}`);
  // --- This ends all commands at level higher than 'level'
  atLevel(level, oOut);
  cur = lCmdStack.TOS();
  if (cur && isTrueCmd(cmd) && (cur.level === level)) {
    // --- end the current command, exec new command
    endCmd(cur, oOut);
    execCmd(cmd, argstr, level, oOut);
    // --- simply replace current TOS with this command
    lCmdStack[lCmdStack.length - 1] = {
      cmd,
      state: 1,
      level
    };
  } else if (lCmdStack.empty() || (level > cur.level)) {
    // --- lower level, start a new command
    execCmd(cmd, argstr, level, oOut);
    lCmdStack.push({
      cmd,
      state: 1,
      level
    });
  } else {
    execCmd(cmd, argstr, level, oOut);
    // --- check if this command is allowed here
    //     throws error if invalid transition
    next = nextState(cur.cmd, cur.state, cmd);
    debug(`   NEXT STATE: ${next}`);
    if (next == null) {
      error(`Bad command #${cmd} - `);
    }
    lCmdStack.TOS().state = next;
  }
  if (debugging) {
    lCmdStack.dump();
  }
};

// ---------------------------------------------------------------------------
export var finished = function(oOut) {
  atLevel(-1, oOut);
};

// ---------------------------------------------------------------------------
//       Utility functions
// ---------------------------------------------------------------------------
//    End all commands at higher level
atLevel = function(level, oOut) {
  var hCmd;
  if (!(oOut instanceof Output)) {
    error("atLevel(): oOut not instance of Output");
  }
  // --- End all commands at higher level
  while (lCmdStack.nonempty() && (lCmdStack.TOS().level > level)) {
    hCmd = lCmdStack.pop();
    endCmd(hCmd, oOut);
  }
};

// ---------------------------------------------------------------------------
isTrueCmd = function(cmd) {
  return ['if', 'for', 'await', 'const', 'log'].indexOf(cmd) >= 0;
};

// ---------------------------------------------------------------------------
// Should throw error if the command can't end in its current state
endCmd = function(hCmd, oOut) {
  var cmd, level, state;
  if (!hCmd) {
    error("endCmd(): empty command rec");
  }
  ({cmd, state, level} = hCmd);
  debug(`DEBUG: endCmd ${cmd}`);
  switch (cmd) {
    case 'if':
      oOut.put("\{\/if\}", level);
      break;
    case 'for':
      oOut.put("\{\/each\}", level);
      break;
    case 'await':
      if (state === 1) {
        error("endCmd('#await'): #then section expected");
      }
      oOut.put("\{\/await\}", level);
      break;
    case 'const':
    case 'log':
      pass;
      break;
    default:
      error(`endCmd('#${cmd}'): Not a true command`);
  }
};

// ---------------------------------------------------------------------------
nextState = function(cmd, state, newCmd) {
  var hCmds, hStates;
  if (hTransitions[cmd] == null) {
    return undef;
  }
  hStates = hTransitions[cmd];
  if (hStates[state] == null) {
    return undef;
  }
  hCmds = hStates[state];
  if (!hCmds[newCmd]) {
    return undef;
  }
  return hCmds[newCmd];
};

// ---------------------------------------------------------------------------
hTransitions = {};

// ---------------------------------------------------------------------------
allow = function(cmd, state, nextCmd, nextState) {
  if (!hTransitions[cmd]) {
    hTransitions[cmd] = {};
  }
  if (!hTransitions[cmd][state]) {
    hTransitions[cmd][state] = {};
  }
  if (!hTransitions[cmd][state][nextCmd]) {
    hTransitions[cmd][state][nextCmd] = nextState;
  }
};

// ---------------------------------------------------------------------------
allow('if', 1, 'elsif', 1);

allow('if', 1, 'else', 2);

allow('await', 1, 'then', 2);

allow('await', 2, 'catch', 3);

// ---------------------------------------------------------------------------
// export because this is called directly in blocks, e.g.
//           div:markdown
//           script
//           style
export var execCmd = function(cmd, argstr, level, oOut) {
  var _, eachstr, expr, index, key, lMatches, name, value, varname;
  assert(oOut instanceof StarbucksOutput);
  switch (cmd) {
    case 'const':
      lMatches = argstr.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*=(.*)$/); // const name
      // expression
      if (lMatches != null) {
        [_, name, value] = lMatches;
        oOut.setConst(name, value.trim());
      } else {
        error("Invalid #const command");
      }
      return;
    case 'if':
      oOut.put(`\{\#if ${argstr}\}`, level);
      return;
    case 'elsif':
      oOut.put(`\{\:else if ${argstr}\}`, level);
      return;
    case 'else':
      if (argstr) {
        error("#else cannot have arguments");
      }
      oOut.put("\{\:else\}", level);
      return;
    case 'for':
      lMatches = argstr.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:,([A-Za-z_][A-Za-z0-9_]*))?\s+in\s+(.*?)(?:\s*\(\s*key\s*=\s*(.*)\s*\))?$/); // variable name
      // index variable name
      // '(key = '
      // the key
      // ')'
      // key is optional
      if (lMatches != null) {
        [_, varname, index, expr, key] = lMatches;
        if (index) {
          eachstr = `\#each ${expr} as ${varname},${index}`;
        } else {
          eachstr = `\#each ${expr} as ${varname}`;
        }
        if (key) {
          eachstr += ` (${key})`;
        }
      } else {
        throw "Invalid #for command";
      }
      oOut.put(`\{${eachstr}\}`, level);
      return;
    case 'await':
      oOut.put(`\{\#await ${argstr}\}`, level);
      return;
    case 'then':
      oOut.put(`\{\:then ${argstr}\}`, level);
      return;
    case 'catch':
      oOut.put(`\{\:catch ${argstr}\}`, level);
      return;
    case 'log':
      if (argstr === "on" || argstr === "") {
        oOut.doLog(true);
      } else if (argstr === "off") {
        oOut.doLog(false);
      } else {
        throw "Invalid #log command";
      }
      return;
    default:
      error(`execCmd(): Unknown command: '${cmd}'`);
  }
};

// ---------------------------------------------------------------------------
// if true, returns { cmd, argstr }
export var isCommand = function(line, wantCmd = undef) {
  var _, argstr, cmd, hToken, lMatches;
  assert(!line.match(/^\s/));
  lMatches = line.match(/^\#(\S+)\s*(.*)$/); // skip whitespace following command
  // command arguments
  if (!lMatches) {
    return undef;
  }
  [_, cmd, argstr] = lMatches;
  if (wantCmd && (cmd !== wantCmd)) {
    return undef;
  }
  hToken = {cmd};
  if (argstr) {
    hToken.argstr = argstr;
  }
  return hToken;
};
