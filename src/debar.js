// Generated by CoffeeScript 2.7.0
  // debar.coffee
import {
  assert
} from '@jdeighan/unit-tester/utils';

import {
  undef,
  pass,
  OL,
  isEmpty,
  nonEmpty,
  replaceVars
} from '@jdeighan/coffee-utils';

import {
  indented,
  indentation
} from '@jdeighan/coffee-utils/indent';

import {
  toArray,
  toBlock
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Mapper,
  map
} from '@jdeighan/mapper';

import {
  TreeWalker
} from '@jdeighan/mapper/tree';

export var sep = '=';

// ---------------------------------------------------------------------------
export var debarStr = function(str, level = 0) {
  assert(str !== sep, `cannot use with ${OL(sep)}`);
  return `${indentation(level)}\# |||| ${str}`;
};

// ---------------------------------------------------------------------------
export var debarSep = function() {
  return `\# |||| ${sep}`;
};

// ---------------------------------------------------------------------------
// Retains comments like:
//    # |||| <anything>
// Removes all other comments
// ---------------------------------------------------------------------------
export var DebarPreMapper = class DebarPreMapper extends TreeWalker {
  mapComment(hNode) {
    var comment, level, str, uobj;
    ({str, uobj, level} = hNode);
    ({comment} = uobj);
    if (comment.indexOf('||||') === 0) {
      return str;
    } else {
      return undef;
    }
  }

};

// ---------------------------------------------------------------------------
// Converts:
//    # |||| <anything>
// To:
//    <anything>
// NOTE:
//    maintains indentation
//    allows // in place of #

// ---------------------------------------------------------------------------
export var DebarPostMapper = class DebarPostMapper extends Mapper {
  isComment(hNode) {
    // --- Handle both CoffeeScript and JavaScript comments
    if (hNode.str.indexOf('# ') === 0) {
      hNode.uobj = {
        comment: hNode.str.substring(2).trim()
      };
      return true;
    } else if (hNode.str.indexOf('// ') === 0) {
      hNode.uobj = {
        comment: hNode.str.substring(3).trim()
      };
      return true;
    } else {
      return false;
    }
  }

  // ..........................................................
  mapComment(hLine) {
    var _, comment, lMatches, level, result, str, tail, uobj;
    debug("enter DebarPostMapper.mapComment()", hLine);
    ({str, uobj, level} = hLine);
    ({comment} = uobj);
    if (lMatches = comment.match(/^\|\|\|\|\s*(.*)$/)) { // 4 vertical bars
      [_, tail] = lMatches;
      result = indented(tail, level, this.oneIndent);
      debug("return from DebarPostMapper.mapComment()", result);
      return result;
    }
    debug("return undef from DebarPostMapper.mapComment()");
    return undef;
  }

};

// ---------------------------------------------------------------------------
export var debar = function(block, source = undef) {
  var i, j, lBlocks, lCurBlock, lItems, lRetVal, len, len1, ref, str;
  // --- Returns an array of blocks
  debug("enter debar()", block);
  block = map(source, block, [DebarPreMapper, DebarPostMapper]);
  debug("map to", block);
  if (isEmpty(block)) {
    debug("return undef from debar() - empty result");
    return '';
  }
  // --- separate into blocks on debarSep()
  lCurBlock = [];
  lBlocks = [lCurBlock]; // array of arrays
  ref = toArray(block);
  for (i = 0, len = ref.length; i < len; i++) {
    str = ref[i];
    if (str === sep) {
      lCurBlock = [];
      lBlocks.push(lCurBlock);
    } else {
      lCurBlock.push(str);
    }
  }
  // --- convert items (which are arrays) to blocks
  lRetVal = [];
  for (j = 0, len1 = lBlocks.length; j < len1; j++) {
    lItems = lBlocks[j];
    lRetVal.push(toBlock(lItems));
  }
  debug("return from debar()", lRetVal);
  return lRetVal;
};
