// Generated by CoffeeScript 2.7.0
  // StarbucksTreeWalker.coffee
import {
  assert,
  pass,
  undef,
  defined,
  croak,
  isEmpty,
  nonEmpty,
  isString,
  isHash,
  isArray
} from '@jdeighan/coffee-utils';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  log,
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  phStr,
  phReplace
} from '@jdeighan/coffee-utils/placeholders';

import {
  parsetag,
  tag2str
} from '@jdeighan/mapper/parsetag';

import {
  TreeWalker
} from '@jdeighan/mapper/tree';

import {
  markdownify
} from '@jdeighan/mapper/markdown';

import {
  sassify
} from '@jdeighan/mapper/sass';

import {
  cieloCodeToJS
} from '@jdeighan/mapper/cielo';

import {
  SectionMap
} from '@jdeighan/mapper/sectionmap';

// import {getMediaQuery} from '@jdeighan/starbucks/media'

  // ---------------------------------------------------------------------------
export var StarbucksTreeWalker = class StarbucksTreeWalker extends TreeWalker {
  init() {
    this.kind = this.hSourceInfo.purpose; // may be undef
    if (defined(this.kind)) {
      assert((this.kind === 'webpage') || (this.kind === 'component'), "type is $type");
    }
    // --- Set in parseHeader()
    this.lParms = undef;
    this.lStores = [];
    this.keyhandler = undef;
    this.sectMap = new SectionMap(['html', ['export', 'import', 'code'], 'style']);
    this.sectMap.addSet('Script', ['export', 'import', 'code']);
  }

  // ..........................................................
  mapStr(str, level) {
    var hToken;
    // --- level is the level in the source code

    // --- interpret HTML tags
    //   - return object, which will be passed to visit(), endVisit()

    // --- hToken is:
    //        type: 'tag'
    //        tag:  <tagName>
    //        subtype: <subtype>    # optional
    //        hAttr:  <hAttr>       # optional
    //        containedText: <text> # optional
    hToken = parsetag(str);
    return hToken;
  }

  // ..........................................................
  handleCmd(cmd, argstr, prefix, h) {
    var item;
    switch (cmd) {
      case 'starbucks':
        assert(prefix === '', "non-empty prefix in header line");
        return this.parseHeader(argstr);
      case 'if':
      case 'for':
      case 'await':
      case 'error':
      case 'else':
        return {cmd, argstr};
      default:
        item = super.handleCmd(cmd, argstr, prefix, h);
        return item;
    }
  }

  // ..........................................................
  beginWalk() {
    return undef;
  }

  // ..........................................................
  visit(hToken, hUser, level, lStack) {
    var code, cssCode, fname, html, jsCode, md, pre, result, source, stmt, subtype, tag, tagName, text;
    // --- level is the adjusted level
    debug("enter visit()", hToken, hUser, level);
    switch (hToken.type) {
      case 'tag':
        tagName = hToken.tag;
        subtype = hToken.subtype;
        text = hToken.containedText;
        tag = tag2str(hToken, 'begin');
        switch (tagName) {
          case 'script':
            assert(isEmpty(text), "script cannot have contained text");
            code = this.fetchBlockAtLevel(level + 1);
            switch (subtype) {
              case 'startup':
                pass;
                break;
              default:
                jsCode = cieloCodeToJS(code, this.hSourceInfo.fullpath);
                debug('jsCode', jsCode);
                this.sectMap.section('code').add(jsCode);
                debug("return undef from visit() - add script");
                return undef;
            }
            break;
          case 'style':
            assert(isEmpty(text), "style cannot have contained text");
            code = this.fetchBlockAtLevel(level + 1);
            cssCode = sassify(code, this.hSourceInfo.fullpath);
            debug('cssCode', cssCode);
            this.sectMap.section('style').add(cssCode);
            debug("return undef from visit() - add style");
            return undef;
          case 'div':
            switch (subtype) {
              case 'sourcecode':
                code = process.env['cielo.SOURCECODE'];
                result = arrayToBlock([indented(tag, level), indented("<pre>", level + 1), indented(code, level + 2)]);
                break;
              case 'markdown':
                md = this.fetchBlockAtLevel(level + 1);
                html = markdownify(md);
                result = arrayToBlock([indented(tag, level), indented(html, level + 1)]);
                break;
              case 'pre':
                pre = this.fetchBlockAtLevel(level + 1);
                result = arrayToBlock([indented(tag, level), indented('<pre>', level + 1), indented(pre, level + 2)]);
            }
            break;
          default:
            // --- Tag name begins with capital letter
            if (tagName.match(/^[A-Z]/)) {
              fname = `${tagName}.svelte`;
              source = this.pathTo(fname);
              assert(defined(source), `Can't find file ${fname}`);
              stmt = `import {${tagName}} from '${source}';`;
              this.sectMap.section('import').add(stmt);
            }
        }
        if (result === undef) {
          result = this.defaultHtml(tag, text, level);
        }
        break;
      case 'cmd':
        result = undef;
        break;
      default:
        croak("Bad token", hToken);
    }
    debug("return from visit()", result);
    return result;
  }

  // ..........................................................
  endVisit(hToken, hUser, level, lStack) {
    var endTag, result, tagName;
    // --- level is the adjusted level
    debug("enter endVisit()", hToken, hUser, level);
    switch (hToken.type) {
      case 'tag':
        tagName = hToken.tag;
        if ((tagName === 'script') || (tagName === 'style')) {
          debug(`return undef from endVisit() - ${tagName}`);
          return undef;
        }
        // --- endTag is undef for some tags, i.e. <img>, etc.
        if (defined(endTag = tag2str(hToken, 'end'))) {
          switch (tagName) {
            case 'div':
              result = [];
              switch (hToken.subtype) {
                case 'sourcecode':
                case 'pre':
                  result.push(indented("</pre>", 1));
              }
              result.push(endTag);
              break;
            default:
              result = [endTag];
          }
        }
        break;
      case 'cmd':
        pass;
        break;
      default:
        croak("Bad token", hToken);
    }
    if (defined(result)) {
      result = indented(result, level);
      debug("return from endVisit()", result);
      return result;
    } else {
      debug("return undef from endVisit()");
      return undef;
    }
  }

  // ..........................................................
  defaultHtml(tag, text, level) {
    var result;
    if (nonEmpty(text)) {
      return arrayToBlock([indented(tag, level), indented(text, level + 1)]);
    } else {
      return result = indented(tag, level);
    }
  }

  // ..........................................................
  endWalk() {
    var text;
    if ((this.kind === 'webpage') && nonEmpty(this.lParms)) {
      // --- If no startup section defined, output this:
      text = `export load = ({page}) ->
	return {props: {${lParms.join(',')}}}`;
    }
    return undef;
  }

  // ..........................................................
  finalizeBlock(block) {
    var result;
    debug("enter finalizeBlock()", block);
    // --- Add block to html section
    this.sectMap.section('html').add(block);
    // --- Add <script> ... </script> if non-empty
    if (this.sectMap.nonEmpty('Script')) {
      this.sectMap.enclose('Script', '<script>', '</script>');
    }
    // --- Add <style> ... </style> if non-empty
    if (this.sectMap.nonEmpty('style')) {
      this.sectMap.enclose('style', '<style>', '</style>');
    }
    result = this.sectMap.getBlock();
    debug("return from finalizeBlock()", result);
    return result;
  }

  // ..........................................................
  parseParms(lParms) {
    var i, len, parm;
    assert(isUniqueList(lParms), "parameters not unique");
    if (this.kind === 'component') {
      for (i = 0, len = lParms.length; i < len; i++) {
        parm = lParms[i];
        this.sectMap.section('export').add(`export ${parm} = undef;`);
      }
    }
  }

  // ..........................................................
  parseHeader(argstr) {
    var _, i, j, kind, lMatches, len, len1, name, opt, optionstr, parmStr, ref, ref1, value;
    lMatches = argstr.match(/^(webpage|component)?\s*(?:\(([^\)]*)\)\s*)?(.*)$/); // parameters
    // open paren
    // anything except ) - parameters to component
    // close paren
    // options
    assert(lMatches, `Invalid header: '#starbucks ${argstr}'`);
    [_, kind, parmStr, optionstr] = lMatches;
    if (defined(kind)) {
      if (defined(this.kind)) {
        assert(kind === this.kind, "$kind, should be $@kind");
      } else {
        this.kind = kind;
      }
    } else {
      assert(defined(this.kind), "No kind is defined");
    }
    if (nonEmpty(parmStr)) {
      this.parseParms(parmStr.trim().split(/\s*,\s*/));
    }
    // --- if debugging, turn it on before calling debug()
    if (isString(optionstr) && optionstr.match(/\bdebug\b/)) {
      setDebugging(true);
    }
    debug("Parsing #starbucks header line");
    if (nonEmpty(optionstr)) {
      ref = optionstr.trim().split(/\s+/);
      for (i = 0, len = ref.length; i < len; i++) {
        opt = ref[i];
        [name, value] = opt.split(/=/, 2);
        if (value === '') {
          value = '1';
        }
        debug(`OPTION ${name} = '${value}'`);
        switch (name) {
          case 'debug':
            pass;
            break;
          case 'store':
          case 'stores':
            ref1 = value.split(/\,/);
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              name = ref1[j];
              this.lStores.push(name);
            }
            break;
          case 'keyhandler':
            this.keyhandler = value;
            break;
          default:
            croak(`Unknown option: ${name}`);
        }
      }
    }
    return undef;
  }

};
