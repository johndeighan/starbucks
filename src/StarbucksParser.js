// Generated by CoffeeScript 2.5.1
// StarbucksParser.coffee
/*

PLLParser already handles:
	- #include
	- continuation lines
	- HEREDOCs

However, it's handling of HEREDOCs doesn't evaluate the HEREDOC sections,
so we override patchLine() to call patch() with evaluate = true

We leave handleEmptyLine() alone, so empty lines will be skipped

Furthermore PLLParser treats all lines as simply strings. We need to
generate objects with key 'type' so we override mapString() to
generate objects

*/
var CWS, isBlockTag, removeCR, splitBlock;

import {
  strict as assert
} from 'assert';

import {
  say,
  pass,
  undef,
  error,
  warn,
  isEmpty,
  nonEmpty,
  isString,
  firstLine
} from '@jdeighan/coffee-utils';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  PLLParser
} from '@jdeighan/string-input/pll';

import {
  isTAML,
  taml
} from '@jdeighan/string-input/convert';

import {
  SvelteOutput
} from '@jdeighan/svelte-output';

removeCR = function(block) {
  return block.replace(/\r/g, '');
};

splitBlock = function(block) {
  var pos;
  block = removeCR(block);
  if (pos = block.indexOf("\n")) {
    // --- pos is also the length of the 1st line
    //     2nd arg to substr() is number of characters to return
    return [block.substr(0, pos), block.substr(pos + 1)];
  } else {
    return [block, ''];
  }
};

CWS = function(block) {
  return block.trim().replace(/\s+/g, ' ');
};

// ---------------------------------------------------------------------------
// export to allow unit testing
export var splitHeredocHeader = function(line) {
  var lParts;
  lParts = line.trim().split(/\s+/);
  if (lParts.length === 1) {
    return [lParts[0], undef];
  } else if (lParts.length === 2) {
    return lParts;
  } else {
    return undef;
  }
};

// ---------------------------------------------------------------------------
//   class StarbucksParser
export var StarbucksParser = class StarbucksParser extends PLLParser {
  constructor(content, oOutput) {
    super(content);
    this.oOutput = oOutput;
    assert(this.oOutput, "StarbucksParser: oOutput is undef");
    assert(this.oOutput instanceof SvelteOutput, "StarbucksParser: oOutput not a SvelteOutput");
  }

  // ..........................................................
  // --- This is called for each '<<<' in a line
  heredocStr(block) {
    var text, type, val, varname;
    // --- block is a multi-line string
    [type, text, varname] = this.parseHereDoc(block);
    switch (type) {
      case 'string':
        varname = this.oOutput.addVar(text, varname);
        break;
      case 'taml':
        varname = this.oOutput.addTAML(text, varname);
        break;
      case 'function':
        varname = this.oOutput.addFunction(text, varname);
        break;
      default:
        error(`heredocStr(): Invalid type: '${type}'`);
    }
    if (isTAML(block)) {
      val = taml(block);
    }
    return varname;
  }

  // ..........................................................
  // Returns array: [<type>, <body>, <varname>]
  //    type can be one of: 'string', 'function', 'taml')
  parseHereDoc(block) {
    var _, funcname, header, lMatches, lParts, marker, rest, varname;
    [header, rest] = splitBlock(block);
    if ((lMatches = header.match(/^\s*(?:([A-Za-z_][A-Za-z0-9_]*)\s*=\s*)?\(\s*(?:[A-Za-z_][A-Za-z0-9_]*(?:,\s*[A-Za-z_][A-Za-z0-9_]*)*)?\)\s*->\s*$/))) { // function name
      // optional parameters
      [_, funcname] = lMatches;
      return ['function', block, funcname];
    } else {
      lParts = splitHeredocHeader(header);
      if (lParts != null) {
        [marker, varname] = lParts;
        if (marker === '---') {
          return ['taml', block, varname];
        } else if (marker === '&&&') {
          return ['string', rest, varname];
        } else if (marker === '$$$') {
          return ['string', CWS(rest), varname];
        } else {
          return ['string', block, undef];
        }
      } else {
        return ['string', block, undef];
      }
    }
  }

  // ..........................................................
  mapString(str, level) {
    var _, cmd, hToken, lMatches, rest;
    // --- empty lines and comments have been handled
    //     line has been split
    //     continuation lines have been merged
    //     HEREDOC sections have been patched
    //     if undef is returned, the line is ignored
    assert(isString(str), "StarbucksParser.mapString(): not a string");
    if (lMatches = str.match(/^\#([a-z]*)\s*(.*)$/)) { // command (or empty for comment)
      // skip whitespace
      // the rest of the line
      [_, cmd, rest] = lMatches;
      if (cmd.length === 0) {
        return undef;
      }
      if (cmd === 'starbucks') {
        hToken = this.parseHeaderLine(rest);
      } else {
        hToken = this.parseCommand(cmd, rest);
      }
    } else {
      // --- treat as an element
      hToken = parsetag(str);
      if (isBlockTag(hToken)) {
        hToken.blockText = this.fetchBlock(level + 1);
      }
    }
    debug(hToken, "hToken:");
    return hToken;
  }

  // ..........................................................
  parseHeaderLine(rest) {
    var _, hToken, kind, lMatches, optionstr, parms;
    lMatches = rest.match(/^(webpage|component)\s*(?:\(([^\)]*)\)\s*)?(.*)\s*$/); // parameters
    // open paren
    // anything except ) - parameters to component
    // close paren
    // options
    // allow trailing whitespace
    assert(lMatches, "Invalid #starbucks header");
    [_, kind, parms, optionstr] = lMatches;
    if (parms != null) {
      parms = parms.trim();
    }
    // --- if debugging, turn it on before calling debug()
    if (optionstr && optionstr.match(/\bdebug\b/)) {
      setDebugging(true);
    }
    debug("Parsing #starbucks header line");
    hToken = {
      type: "#starbucks",
      kind: kind
    };
    if (optionstr) {
      hToken.optionstr = optionstr;
    }
    if (parms) {
      hToken.lParms = parms.split(/\s*,\s*/);
    }
    debug(hToken, "GOT TOKEN:");
    return hToken;
  }

  // ..........................................................
  parseCommand(cmd, rest) {
    var hToken;
    hToken = {
      type: `#${cmd}`
    };
    if (rest) {
      hToken.argstr = rest;
    }
    return hToken;
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var parsetag = function(line) {
  var _, all, attrName, br_val, className, dq_val, hAttr, hToken, i, lClasses, lMatches, len, modifiers, prefix, quote, ref, rest, sq_val, subtype, tagName, uq_val, value, varName;
  if (lMatches = line.match(/^(?:([A-Za-z][A-Za-z0-9_]*)\s*=\s*)?([A-Za-z][A-Za-z0-9_]*)(?:\:([a-z]+))?(\S*)\s*(.*)$/)) { // variable name
    // variable is optional
    // tag name
    // modifiers (class names, etc.)
    // attributes & enclosed text
    [_, varName, tagName, subtype, modifiers, rest] = lMatches;
    if ((tagName === 'svelte') && subtype) {
      tagName = `${tagName}:${subtype}`;
      subtype = undef;
    }
  } else {
    error(`parsetag(): Invalid HTML: '${line}'`);
  }
  switch (subtype) {
    case undef:
    case '':
      pass;
      break;
    case 'startup':
    case 'onmount':
    case 'ondestroy':
      if (tagName !== 'script') {
        error(`parsetag(): subtype '${subtype}' only allowed with script`);
      }
      break;
    case 'markdown':
    case 'sourcecode':
      if (tagName !== 'div') {
        error("parsetag(): subtype 'markdown' only allowed with div");
      }
  }
  // --- Handle classes added via .<class>
  lClasses = [];
  if (subtype === 'markdown') {
    lClasses.push('markdown');
  }
  if (modifiers) {
    // --- currently, these are only class names
    while (lMatches = modifiers.match(/^\.([A-Za-z][A-Za-z0-9_]*)/)) {
      [all, className] = lMatches;
      lClasses.push(className);
      modifiers = modifiers.substring(all.length);
    }
    if (modifiers) {
      error(`parsetag(): Invalid modifiers in '${line}'`);
    }
  }
  // --- Handle attributes
  hAttr = {}; // { name: {
  //      value: <value>,
  //      quote: <quote>,
  //      }, ...
  //    }
  if (varName) {
    hAttr['bind:this'] = {
      value: varName,
      quote: '{'
    };
  }
  if (rest) {
    while (lMatches = rest.match(/^(?:(?:(bind|on):)?([A-Za-z][A-Za-z0-9_]*))=(?:\{([^}]*)\}|"([^"]*)"|'([^']*)'|([^"'\s]+))\s*/)) { // prefix
      // attribute name
      // attribute value
      [all, prefix, attrName, br_val, dq_val, sq_val, uq_val] = lMatches;
      if (br_val) {
        value = br_val;
        quote = '{';
      } else {
        assert(prefix == null, "prefix requires use of {...}");
        if (dq_val) {
          value = dq_val;
          quote = '"';
        } else if (sq_val) {
          value = sq_val;
          quote = "'";
        } else {
          value = uq_val;
          quote = '';
        }
      }
      if (prefix) {
        attrName = `${prefix}:${attrName}`;
      }
      if (attrName === 'class') {
        ref = value.split(/\s+/);
        for (i = 0, len = ref.length; i < len; i++) {
          className = ref[i];
          lClasses.push(className);
        }
      } else {
        if (hAttr.attrName != null) {
          error(`parsetag(): Multiple attributes named '${attrName}'`);
        }
        hAttr[attrName] = {value, quote};
      }
      rest = rest.substring(all.length);
    }
  }
  // --- The rest is contained text
  rest = rest.trim();
  if (lMatches = rest.match(/^['"](.*)['"]$/)) {
    rest = lMatches[1];
  }
  // --- Add class attribute to hAttr if there are classes
  if (lClasses.length > 0) {
    hAttr.class = {
      value: lClasses.join(' '),
      quote: '"'
    };
  }
  // --- If subtype == 'startup'
  if (subtype === 'startup') {
    if (!hAttr.context) {
      hAttr.context = {
        value: 'module',
        quote: '"'
      };
    }
  }
  // --- Build the return value
  hToken = {
    type: 'tag',
    tag: tagName
  };
  if (subtype) {
    hToken.subtype = subtype;
  }
  if (nonEmpty(hAttr)) {
    hToken.hAttr = hAttr;
  }
  // --- Is there contained text?
  if (rest) {
    hToken.containedText = rest;
  }
  return hToken;
};

// ---------------------------------------------------------------------------
isBlockTag = function(hTag) {
  var subtype, tag;
  ({tag, subtype} = hTag);
  return (tag === 'script') || (tag === 'style') || (tag === 'pre') || ((tag === 'div') && (subtype === 'markdown')) || ((tag === 'div') && (subtype === 'sourcecode'));
};

// ---------------------------------------------------------------------------
export var attrStr = function(hAttr) {
  var attrName, bquote, equote, i, len, quote, ref, str, value;
  if (!hAttr) {
    return '';
  }
  str = '';
  ref = Object.getOwnPropertyNames(hAttr);
  for (i = 0, len = ref.length; i < len; i++) {
    attrName = ref[i];
    ({value, quote} = hAttr[attrName]);
    if (quote === '{') {
      bquote = '{';
      equote = '}';
    } else {
      bquote = equote = quote;
    }
    str += ` ${attrName}=${bquote}${value}${equote}`;
  }
  return str;
};

// ---------------------------------------------------------------------------
export var tag2str = function(hToken) {
  var str;
  str = `<${hToken.tag}`;
  if (nonEmpty(hToken.hAttr)) {
    str += attrStr(hToken.hAttr);
  }
  str += '>';
  return str;
};
