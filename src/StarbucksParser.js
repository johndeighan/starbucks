// Generated by CoffeeScript 2.6.1
// StarbucksParser.coffee
var isBlockTag;

import {
  assert,
  pass,
  undef,
  error,
  warn,
  isEmpty,
  nonEmpty,
  isString,
  CWS
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock,
  firstLine
} from '@jdeighan/coffee-utils/block';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  log
} from '@jdeighan/coffee-utils/log';

import {
  PLLParser
} from '@jdeighan/string-input';

import {
  isTAML,
  taml
} from '@jdeighan/string-input/taml';

import {
  SvelteOutput
} from '@jdeighan/svelte-output';

import {
  mapHereDoc,
  isFunctionHeader
} from '@jdeighan/string-input/heredoc';

/*

PLLParser already handles:
	- #include
	- continuation lines
	- HEREDOCs

However, it's handling of HEREDOCs doesn't evaluate the HEREDOC sections,
so we override patchLine() to call patch() with evaluate = true

We leave handleEmptyLine() alone, so empty lines will be skipped

Furthermore PLLParser treats all lines as simply strings. We need to
generate objects with key 'type' so we override mapString() to
generate objects

*/
// ---------------------------------------------------------------------------
// export to allow unit testing
export var splitHeredocHeader = function(line) {
  var lParts;
  lParts = line.trim().split(/\s+/);
  if (lParts.length === 1) {
    return [lParts[0], undef];
  } else if (lParts.length === 2) {
    return lParts;
  } else {
    return undef;
  }
};

// ---------------------------------------------------------------------------
//   class StarbucksParser
export var StarbucksParser = class StarbucksParser extends PLLParser {
  constructor(content, oOutput) {
    super(content);
    this.oOutput = oOutput;
    assert(this.oOutput, "StarbucksParser: oOutput is undef");
    assert(this.oOutput instanceof SvelteOutput, "StarbucksParser: oOutput not a SvelteOutput");
  }

  // ..........................................................
  mapHereDoc(block) {
    var _, funcBody, funcName, lMatches, strParms, varname;
    // --- override to create anonymous variable
    if (isTAML(block)) {
      varname = this.oOutput.addTAML(block);
    } else if (lMatches = isFunctionHeader(firstLine(block))) {
      [_, funcName, strParms] = lMatches;
      funcBody = `(${strParms}) ->
	${arrayToBlock(lLines)}`;
      varname = this.oOutput.addFunction(funcBody, funcName);
    } else if (block.indexOf('...') === 0) {
      block = block.substr(3); // remove '...'
      varname = this.oOutput.addVar(CWS(block));
    } else {
      varname = this.oOutput.addVar(block);
    }
    return varname;
  }

  // ..........................................................
  mapNode(line, level) {
    var _, cmd, hToken, lMatches, rest;
    // --- empty lines and comments have been handled
    //     line has been split into (level, str)
    //     continuation lines have been merged
    //     HEREDOC sections have been patched
    //     if undef is returned, the line is ignored
    assert(isString(line), "StarbucksParser.mapNode(): not a string");
    if (lMatches = line.match(/^\#([a-z]*)\s*(.*)$/)) { // command (or empty for comment)
      // skip whitespace
      // the rest of the line
      [_, cmd, rest] = lMatches;
      if (cmd.length === 0) {
        return undef;
      }
      if (cmd === 'starbucks') {
        hToken = this.parseHeaderLine(rest);
      } else {
        hToken = this.parseCommand(cmd, rest);
      }
    } else {
      // --- treat as an element
      hToken = parsetag(line);
      // --- if one of:
      //        script,
      //        style,
      //        pre,
      //        div:markdown,
      //        div:sourcecode
      if (isBlockTag(hToken)) {
        hToken.blockText = this.fetchBlock(level + 1);
      }
    }
    debug('hToken', hToken);
    return hToken;
  }

  // ..........................................................
  parseHeaderLine(rest) {
    var _, hToken, kind, lMatches, optionstr, parms;
    lMatches = rest.match(/^(webpage|component)\s*(?:\(([^\)]*)\)\s*)?(.*)\s*$/); // parameters
    // open paren
    // anything except ) - parameters to component
    // close paren
    // options
    // allow trailing whitespace
    assert(lMatches, "Invalid #starbucks header");
    [_, kind, parms, optionstr] = lMatches;
    if (parms != null) {
      parms = parms.trim();
    }
    // --- if debugging, turn it on before calling debug()
    if (optionstr && optionstr.match(/\bdebug\b/)) {
      setDebugging(true);
    }
    debug("Parsing #starbucks header line");
    hToken = {
      type: "#starbucks",
      kind: kind
    };
    if (optionstr) {
      hToken.optionstr = optionstr;
    }
    if (parms) {
      hToken.lParms = parms.split(/\s*,\s*/);
    }
    debug('GOT TOKEN', hToken);
    return hToken;
  }

  // ..........................................................
  parseCommand(cmd, rest) {
    var hToken;
    hToken = {
      type: `#${cmd}`
    };
    if (rest) {
      hToken.argstr = rest;
    }
    return hToken;
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var parsetag = function(line) {
  var _, all, attrName, br_val, className, dq_val, hAttr, hToken, i, lClasses, lMatches, len, modifiers, prefix, quote, ref, rest, sq_val, subtype, tagName, uq_val, value, varName;
  if (lMatches = line.match(/^(?:([A-Za-z][A-Za-z0-9_]*)\s*=\s*)?([A-Za-z][A-Za-z0-9_]*)(?:\:([a-z]+))?(\S*)\s*(.*)$/)) { // variable name
    // variable is optional
    // tag name
    // modifiers (class names, etc.)
    // attributes & enclosed text
    [_, varName, tagName, subtype, modifiers, rest] = lMatches;
    if ((tagName === 'svelte') && subtype) {
      tagName = `${tagName}:${subtype}`;
      subtype = undef;
    }
  } else {
    error(`parsetag(): Invalid HTML: '${line}'`);
  }
  switch (subtype) {
    case undef:
    case '':
      pass;
      break;
    case 'startup':
    case 'onmount':
    case 'ondestroy':
      if (tagName !== 'script') {
        error(`parsetag(): subtype '${subtype}' only allowed with script`);
      }
      break;
    case 'markdown':
    case 'sourcecode':
      if (tagName !== 'div') {
        error("parsetag(): subtype 'markdown' only allowed with div");
      }
  }
  // --- Handle classes added via .<class>
  lClasses = [];
  if (subtype === 'markdown') {
    lClasses.push('markdown');
  }
  if (modifiers) {
    // --- currently, these are only class names
    while (lMatches = modifiers.match(/^\.([A-Za-z][A-Za-z0-9_]*)/)) {
      [all, className] = lMatches;
      lClasses.push(className);
      modifiers = modifiers.substring(all.length);
    }
    if (modifiers) {
      error(`parsetag(): Invalid modifiers in '${line}'`);
    }
  }
  // --- Handle attributes
  hAttr = {}; // { name: { value: <value>, quote: <quote> }, ... }
  if (varName) {
    hAttr['bind:this'] = {
      value: varName,
      quote: '{'
    };
  }
  if (rest) {
    while (lMatches = rest.match(/^(?:(?:(bind|on):)?([A-Za-z][A-Za-z0-9_]*))=(?:\{([^}]*)\}|"([^"]*)"|'([^']*)'|([^"'\s]+))\s*/)) { // prefix
      // attribute name
      // attribute value
      [all, prefix, attrName, br_val, dq_val, sq_val, uq_val] = lMatches;
      if (br_val) {
        value = br_val;
        quote = '{';
      } else {
        assert(prefix == null, "prefix requires use of {...}");
        if (dq_val) {
          value = dq_val;
          quote = '"';
        } else if (sq_val) {
          value = sq_val;
          quote = "'";
        } else {
          value = uq_val;
          quote = '';
        }
      }
      if (prefix) {
        attrName = `${prefix}:${attrName}`;
      }
      if (attrName === 'class') {
        ref = value.split(/\s+/);
        for (i = 0, len = ref.length; i < len; i++) {
          className = ref[i];
          lClasses.push(className);
        }
      } else {
        if (hAttr.attrName != null) {
          error(`parsetag(): Multiple attributes named '${attrName}'`);
        }
        hAttr[attrName] = {value, quote};
      }
      rest = rest.substring(all.length);
    }
  }
  // --- The rest is contained text
  rest = rest.trim();
  if (lMatches = rest.match(/^['"](.*)['"]$/)) {
    rest = lMatches[1];
  }
  // --- Add class attribute to hAttr if there are classes
  if (lClasses.length > 0) {
    hAttr.class = {
      value: lClasses.join(' '),
      quote: '"'
    };
  }
  // --- If subtype == 'startup'
  if (subtype === 'startup') {
    if (!hAttr.context) {
      hAttr.context = {
        value: 'module',
        quote: '"'
      };
    }
  }
  // --- Build the return value
  hToken = {
    type: 'tag',
    tag: tagName
  };
  if (subtype) {
    hToken.subtype = subtype;
  }
  if (nonEmpty(hAttr)) {
    hToken.hAttr = hAttr;
  }
  // --- Is there contained text?
  if (rest) {
    hToken.containedText = rest;
  }
  return hToken;
};

// ---------------------------------------------------------------------------
isBlockTag = function(hTag) {
  var subtype, tag;
  ({tag, subtype} = hTag);
  return (tag === 'script') || (tag === 'style') || (tag === 'pre') || ((tag === 'div') && (subtype === 'markdown')) || ((tag === 'div') && (subtype === 'sourcecode'));
};

// ---------------------------------------------------------------------------
export var attrStr = function(hAttr) {
  var attrName, bquote, equote, i, len, quote, ref, str, value;
  if (!hAttr) {
    return '';
  }
  str = '';
  ref = Object.getOwnPropertyNames(hAttr);
  for (i = 0, len = ref.length; i < len; i++) {
    attrName = ref[i];
    ({value, quote} = hAttr[attrName]);
    if (quote === '{') {
      bquote = '{';
      equote = '}';
    } else {
      bquote = equote = quote;
    }
    str += ` ${attrName}=${bquote}${value}${equote}`;
  }
  return str;
};

// ---------------------------------------------------------------------------
export var tag2str = function(hToken) {
  var str;
  str = `<${hToken.tag}`;
  if (nonEmpty(hToken.hAttr)) {
    str += attrStr(hToken.hAttr);
  }
  str += '>';
  return str;
};
