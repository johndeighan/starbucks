// Generated by CoffeeScript 2.7.0
  // StarbucksMapper.coffee
import {
  undef,
  assert,
  croak,
  isEmpty,
  nonEmpty,
  isUniqueList
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  TreeMapper
} from '@jdeighan/mapper/tree';

import {
  parsetag,
  isBlockTag
} from '@jdeighan/mapper/parsetag';

import {
  SvelteOutput
} from '@jdeighan/svelte-output';

import {
  isCmd,
  foundCmd,
  endCmd
} from '@jdeighan/starbucks/commands';

// ---------------------------------------------------------------------------
export var StarbucksMapper = class StarbucksMapper extends TreeMapper {
  constructor(content, source) {
    super(content, source);
    this.rootDir = this.hSourceInfo.dir; // used for file searches
    this.kind = undef; // if set, we've seen the header line
  }

  
    // ..........................................................
  mapNode(line, level) {
    var hToken;
    // --- Commands don't come here - they go to handleCommand()
    //     Comments don't come here - they go to handleComment()
    //     Empty lines don't come here - they go to handleEmptyLine()
    debug(`enter mapNode(level=${level})`, line);
    // --- treat as an element
    hToken = parsetag(line);
    // --- if one of:
    //        script,
    //        style,
    //        pre,
    //        div:markdown,
    //        div:sourcecode
    if (isBlockTag(hToken)) {
      hToken.blockText = this.fetchBlock(level + 1);
    }
    debug('return from mapNode()', hToken);
    return hToken;
  }

  // ..........................................................
  // --- This only creates a node in the tree
  //     The command is actually handled when the tree is walked
  handleCommand(cmd, argstr, level) {
    var hToken, handled, lResult, result;
    debug(`enter StarbucksMapper.handleCommand('${cmd}', '${argstr}')`);
    // --- CieloMapper.handleCommand must be given a chance
    //     to handle #define commands since lines automatically
    //     have variables substituted
    lResult = super.handleCommand(cmd, argstr, level);
    [handled, result] = lResult;
    if (handled) {
      return lResult;
    }
    if (cmd === 'starbucks') {
      assert(this.kind === undef, "multiple #starbucks headers");
      assert(level === 0, `#starbucks - level is ${level}, not 0`);
      hToken = this.parseHeaderLine(argstr);
      assert(this.kind !== undef, "header failed to set kind");
    } else {
      assert(this.kind !== undef, "missing #starbucks header");
      assert(isCmd(cmd), `Unknown command: '${cmd} ${argstr}'`);
      hToken = {
        type: 'command',
        cmd,
        argstr
      };
    }
    debug("return from StarbucksMapper.handleCommand()", hToken);
    return [true, hToken];
  }

  // ..........................................................
  parseHeaderLine(argstr) {
    var _, filename, fullpath, hStores, i, j, keyhandler, kind, lMatches, lParms, len, len1, name, opt, optionstr, parms, ref, ref1, value;
    lMatches = argstr.match(/^(webpage|component)\s*(?:\(([^\)]*)\)\s*)?(.*)$/); // parameters
    // open paren
    // anything except ) - parameters to component
    // close paren
    // options
    assert(lMatches, `Invalid #starbucks header line: '#starbucks ${argstr}'`);
    [_, kind, parms, optionstr] = lMatches;
    this.kind = kind;
    if (nonEmpty(parms)) {
      lParms = parms.trim().split(/\s*,\s*/);
      assert(isUniqueList(lParms), "parameters not unique");
    } else {
      lParms = undef;
    }
    // --- if debugging, turn it on before calling debug()
    if (optionstr && optionstr.match(/[^\s]debug[\s$]/)) {
      setDebugging(true);
    }
    debug("Parsing #starbucks header line");
    if (nonEmpty(optionstr)) {
      ref = optionstr.trim().split(/\s+/);
      for (i = 0, len = ref.length; i < len; i++) {
        opt = ref[i];
        [name, value] = opt.split(/=/, 2);
        debug(`HOOK header: OPTION ${name} = '${value}'`);
        switch (name) {
          case 'debug':
            setDebugging(true);
            break;
          case 'store':
          case 'stores':
            hStores = {};
            ref1 = value.split(/\,/);
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              name = ref1[j];
              filename = mkpath(name, '.store');
              fullpath = pathTo(filename, this.rootDir);
              assert(fullpath != null, `No such store: ${filename}`);
              hStores[name] = fullpath;
            }
            break;
          case 'keyhandler':
            // @oOutput.putLine "<svelte:window on:keydown={#{value}}/>"
            keyhandler = value;
            break;
          default:
            error(`Unknown option: ${name}`);
        }
      }
    }
    return {
      type: 'header',
      kind,
      lParms,
      hStores,
      keyhandler
    };
  }

  // ..........................................................
  visit(node, hInfo, level) {}

  // ..........................................................
  endVisit(node, hInfo, level) {}

  // ..........................................................
  getResult() {
    return undef;
  }

};

// ---------------------------------------------------------------------------
