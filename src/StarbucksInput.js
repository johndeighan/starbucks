// Generated by CoffeeScript 2.5.1
// StarbucksInput.coffee
var shouldSkip;

import {
  strict as assert
} from 'assert';

import pathlib from 'path';

import {
  undef,
  error,
  isEmpty,
  isComment,
  debug,
  unitTesting
} from '@jdeighan/coffee-utils';

import {
  splitLine,
  indentLevel,
  undentedStr,
  indentedStr
} from '@jdeighan/coffee-utils/indent';

import {
  numHereDocs,
  patch,
  build
} from '@jdeighan/coffee-utils/heredoc';

import {
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  StringInput
} from '@jdeighan/string-input';

import {
  parsetag
} from './parsetag.js';

import {
  isCommand
} from './starbucks_commands.js';

// ---------------------------------------------------------------------------
// Must call AFTER removing indentation
shouldSkip = function(line) {
  return (line === '') || line.match(/^#\s/);
};

// ---------------------------------------------------------------------------
// - returns one of:

//     undef - if comment or empty line

//     #define varname some string

//     { type: 'cmd',
//       cmd: <cmd>,
//       argstr: <argstr>,    # only if non-empty
//       level: <n>,
//       line: <text>,
//       lineNum: <n>,
//       }

//     | plain text

//     { type: 'text',
//       text: <text>,
//       level: <n>,
//       line: <text>,
//       lineNum: <n>,
//       }

//     a.red href="a URL" a link

//     { type: 'tag',
//       tag: <tag>
//       subtype: startup | onmount | ondestroy   # only in 'script'
//              | markdown | sourcecode           # only in 'div'
//       hAttr: { class: 'red', href: 'a URL' }
//       containedText: <text>,   # in non-block tags
//       blockText: <text>        # in block tags
//       level: <n>,
//       line: <text>,
//       lineNum: <n>,
//       }

  // ---------------------------------------------------------------------------
// --- export to allow unit testing
export var StarbucksInput = class StarbucksInput extends StringInput {
  constructor(content, hOptions, patchCallback) {
    super(content, hOptions);
    this.patchCallback = patchCallback;
    assert(this.hOptions.hIncludePaths['.md']);
    assert(this.hIncludePaths['.md']);
  }

  mapLine(line) {
    var argstr, blockText, cmd, hCmd, hToken, lLines, lMatches, lSections, level, n, next, orgLineNum;
    // --- line has indentation stripped off
    [level, line] = splitLine(line);
    // --- skip comments and blank lines
    if (isEmpty(line) || isComment(line)) {
      return undef;
    }
    // --- Don't pull additional lines from the buffer directly
    //     always use @fetch() to maintain correct line numbering
    orgLineNum = this.lineNum; // save line number
    
      // --- merge all continuation lines
    while ((this.lBuffer.length > 0) && (indentLevel(this.lBuffer[0]) >= level + 2)) {
      next = undentedStr(this.fetch());
      line += ' ' + next;
    }
    // --- handle any HEREDOCs
    //        - cannot be empty
    //        - require 1 level indentation for 1st line
    n = numHereDocs(line);
    if (n > 0) {
      lSections = []; // --- will have one subarray for each HEREDOC
      while (n > 0) {
        lLines = [];
        while ((this.lBuffer.length > 0) && !this.lBuffer[0].match(/^\s*$/)) {
          lLines.push(this.fetch());
        }
        if (this.lBuffer.length === 0) {
          error(`EOF while processing HEREDOC
at line ${this.lineNum}
n = ${n}`);
        }
        if (this.lBuffer.length > 0) {
          this.fetch(); // empty line
        }
        lSections.push(lLines);
        n -= 1;
      }
      line = patch(line, lSections, this.patchCallback);
    }
    if (hCmd = isCommand(line)) {
      ({cmd, argstr} = hCmd);
      // --- #include is handled in base class
      if (cmd === 'include') {
        error("StarbucksInput: #include found");
      }
      hToken = {
        type: 'cmd',
        cmd: hCmd.cmd,
        level,
        line,
        lineNum: orgLineNum
      };
      if (hCmd.argstr) {
        hToken.argstr = hCmd.argstr;
      }
    } else if (lMatches = line.match(/^\|\s*(.*)$/)) {
      hToken = {
        type: 'text',
        text: lMatches[1],
        level,
        line,
        lineNum: orgLineNum
      };
    } else {
      hToken = parsetag(line);
      hToken.type = 'tag';
      hToken.level = level;
      hToken.line = line;
      hToken.lineNum = orgLineNum;
      if (isBlockTag(hToken)) {
        blockText = this.fetchBlock(level + 1, hToken);
        if (!isEmpty(blockText)) {
          if (hToken.containedText) {
            error(`<${tag}> with both contained and block text`);
          }
          hToken.blockText = blockText;
        }
      }
    }
    return hToken;
  }

  fetchBlock(atLevel, hToken) {
    var blockText, level, line, newLevel, newString;
    blockText = '';
    while (this.lBuffer.length > 0) {
      if (isEmpty(this.lBuffer[0])) {
        this.fetch();
        continue;
      }
      [level, line] = splitLine(this.lBuffer[0]);
      if (level < atLevel) {
        return blockText;
      }
      // --- use fetch() to maintain line numbering
      this.fetch();
      if (line.match(/^\#\s/)) {
        continue;
      }
      newLevel = level - atLevel; // can't be < 0
      newString = indentedStr(line, newLevel) + '\n';
      debug(`IN fetchBlock(): newString = '${newString}'`);
      blockText += newString;
    }
    debug(`IN fetchBlock() - returning '${blockText}'`);
    return blockText;
  }

};

// ---------------------------------------------------------------------------
export var isBlockTag = function(hToken) {
  var subtype, tag;
  ({tag, subtype} = hToken);
  return (tag === 'script') || (tag === 'style') || (tag === 'pre') || ((tag === 'div') && (subtype === 'markdown')) || ((tag === 'div') && (subtype === 'sourcecode'));
};
