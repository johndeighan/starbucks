// Generated by CoffeeScript 2.5.1
// StringInput.coffee
import fs from 'fs';

import {
  undef,
  deepCopy,
  stringToArray,
  say,
  debug,
  sep_dash
} from '@jdeighan/coffee-utils';

import {
  splitLine,
  indentedStr
} from '@jdeighan/coffee-utils/indent';

// ---------------------------------------------------------------------------
//   class StringInput - stream in lines from a string or array
export var StringInput = class StringInput {
  constructor(content, hOptions = {}) {
    // --- Valid options:
    //        filename
    //        mapper
    if (typeof content === 'object') {
      // -- make a deep copy
      this.lBuffer = deepCopy(content);
    } else {
      this.lBuffer = stringToArray(content);
    }
    this.lineNum = 0;
    this.filename = hOptions.filename || 'unit test';
    this.mapper = hOptions.mapper;
    this.lookahead = undef; // lookahead token
  }

  eof() {
    return this.peek() == null;
  }

  peek() {
    var line, result;
    if (this.lookahead != null) {
      debug("   return lookahead token");
      return this.lookahead;
    }
    if (this.lBuffer.length === 0) {
      debug("   return undef - at EOF");
      return undef;
    }
    line = this.fetch();
    result = this._mapped(line);
    while ((result == null) && (this.lBuffer.length > 0)) {
      line = this.fetch();
      result = this._mapped(line);
    }
    debug(`   return '${result}'`);
    this.lookahead = result;
    return result;
  }

  skip() {
    var line, result;
    debug('SKIP:');
    if (this.lookahead != null) {
      debug("   undef lookahead token");
      this.lookahead = undef;
      return;
    }
    if (this.lBuffer.length === 0) {
      debug("   return - at EOF");
      return;
    }
    line = this.fetch();
    result = this._mapped(line);
    while ((result == null) && (this.lBuffer.length > 0)) {
      line = this.fetch();
      result = this._mapped(line);
    }
    debug("   return");
  }

  get() {
    var line, result, save;
    debug('GET:');
    if (this.lookahead != null) {
      debug("   return lookahead token");
      save = this.lookahead;
      this.lookahead = undef;
      return save;
    }
    if (this.lBuffer.length === 0) {
      debug("   return undef - at EOF");
      return undef;
    }
    line = this.fetch();
    result = this._mapped(line);
    while ((result == null) && (this.lBuffer.length > 0)) {
      line = this.fetch();
      result = this._mapped(line);
    }
    debug(`   return '${result}'`);
    return result;
  }

  _mapped(line) {
    var result;
    debug(`   _MAPPED: '${line}'`);
    console.assert(this.lookahead == null);
    if (!this.mapper) {
      debug(`      no mapper - returning '${line}'`);
      return line;
    }
    result = this.mapper(line, this);
    debug(`      mapped to '${result}'`);
    return result;
  }

  // --- This should be used to fetch from @lBuffer
  //     to maintain proper @lineNum for error messages
  fetch() {
    if (this.lBuffer.length === 0) {
      return undef;
    }
    this.lineNum += 1;
    return this.lBuffer.shift();
  }

  // --- Put one or more lines into lBuffer, to be fetched later
  //     TO DO: maintain correct line numbering!!!
  unfetch(block) {
    var lLines;
    lLines = stringToArray(block);
    return this.lBuffer.unshift(...lLines);
  }

  // --- Fetch a block of text at level or greater than 'level'
  //     as one long string
  // --- Designed to use in a mapper
  fetchBlock(atLevel) {
    var block, level, line, str;
    block = '';
    // --- NOTE: I absolutely hate using a backslash for line continuation
    //           but CoffeeScript doesn't continue while there is an
    //           open parenthesis like Python does :-(
    while ((this.lBuffer.length > 0) && ([level, str] = splitLine(this.lBuffer[0])) && (level >= atLevel) && (line = this.fetch())) {
      block += line + '\n';
    }
    return block;
  }

};

// ---------------------------------------------------------------------------
//   class FileInput - contents from a file
export var FileInput = class FileInput extends StringInput {
  constructor(filepath, mapper = null) {
    var content;
    if (!fs.existsSync(filepath)) {
      throw new Error(`FileInput(): file '${filepath}' does not exist`);
    }
    content = fs.readFileSync(filepath).toString();
    super(content, filepath, mapper);
  }

};

// ---------------------------------------------------------------------------
//   utility func for processing content using a mapper
export var procContent = function(content, mapper) {
  var lLines, oInput, result;
  debug(sep_dash);
  debug(content, "CONTENT (before proc):");
  debug(sep_dash);
  oInput = new StringInput(content, {
    filename: 'proc',
    mapper
  });
  lLines = [];
  while (!oInput.eof()) {
    lLines.push(oInput.get());
  }
  if (lLines.length === 0) {
    result = '';
  } else {
    result = lLines.join('\n') + '\n';
  }
  debug(sep_dash);
  debug(result, "CONTENT (after proc):");
  debug(sep_dash);
  return result;
};

// ---------------------------------------------------------------------------
//    1. Skips blank lines and comments
//    2. returns { level, line, lineNum }
export var SimpleMapper = function(line, oInput) {
  var level, lineNum;
  // --- line has indentation stripped off
  [level, line] = splitLine(line);
  if ((line === '') || line.match(/^#\s/)) {
    return undef; // skip comments and blank lines
  }
  lineNum = oInput.lineNum; // save line number
  return {level, line, lineNum};
};
