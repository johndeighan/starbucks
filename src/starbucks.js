// Generated by CoffeeScript 2.7.0
// starbucks.coffee
var lMyCmds;

import {
  assert,
  croak
} from '@jdeighan/unit-tester/utils';

import {
  pass,
  undef,
  defined,
  notdefined,
  OL,
  words,
  isEmpty,
  nonEmpty,
  isString,
  isHash,
  isInteger
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  log,
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  indented,
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  elem
} from '@jdeighan/coffee-utils/html';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  svelteSourceCodeEsc
} from '@jdeighan/coffee-utils/svelte';

import {
  SectionMap
} from '@jdeighan/coffee-utils/sectionmap';

import {
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  map
} from '@jdeighan/mapper';

import {
  TreeWalker
} from '@jdeighan/mapper/tree';

import {
  markdownify
} from '@jdeighan/mapper/markdown';

import {
  isTAML,
  taml
} from '@jdeighan/mapper/taml';

import {
  CieloToCoffeeMapper,
  CieloToJSMapper
} from '@jdeighan/mapper/cielo';

import {
  sassify
} from '@jdeighan/mapper/sass';

import {
  debarStr,
  debar
} from '@jdeighan/starbucks/debar';

import {
  parsetag,
  attrStr,
  tag2str
} from '@jdeighan/starbucks/parsetag';

// --- commands recognized by starbucks
lMyCmds = words('starbucks if else await');

// ---------------------------------------------------------------------------
export var starbucks = function({content, filename}, hOptions = {}) {
  var code, result;
  debug("enter starbucks()");
  assert(isString(content), "content not a string");
  assert(filename, "starbucks(): missing path/url");
  // --- set env var to support <div:sourcecode>
  process.env['cielo.SOURCECODE'] = svelteSourceCodeEsc(content);
  code = map(filename, content, StarbucksMapper, hOptions);
  result = {
    code,
    map: null
  };
  debug("return from starbucks()", result);
  return result;
};

// ---------------------------------------------------------------------------
export var StarbucksMapper = class StarbucksMapper extends TreeWalker {
  init() {
    this.kind = this.hSourceInfo.purpose; // may be undef
    if (defined(this.kind)) {
      assert((this.kind === 'webpage') || (this.kind === 'component'), "type is $type");
    }
    // --- Set in parseHeader()
    this.headerFound = false;
    this.lParms = undef;
    this.lStores = [];
    this.keyhandler = undef;
    this.numVars = 0; // used in creating new variable names
    this.scriptType = 'js'; // can also be 'cielo' or 'coffee'
    this.styleType = 'css'; // can also be 'sass'
    this.markdownType = 'html'; // can also be 'markdown'
    this.sectMap = new SectionMap([
      'html',
      [
        'Script', // all this gets processed by CoffeeScript
        'startup',
        '# |||| =', // we can split up the script code here
        'export',
        'import',
        'vars',
        'onmount',
        'ondestroy',
        'code'
      ],
      'style'
    ]);
  }

  // ..........................................................
  mapComment(hNode) {
    var level, str;
    // --- Retain comments
    ({str, level} = hNode);
    return indented(str, level, this.oneIndent);
  }

  // ..........................................................
  mapNode(hNode) {
    var block, hToken, srcLevel, str, subtype, tagName, text;
    //     only called for "non-special" lines
    //        i.e. not commands, comments or empty lines
    // --- interpret HTML tags
    //   - return hNode, which will be passed to visit(), endVisit()

    // --- hToken is:
    //        type:    'tag'
    //        tagName: <tagName>
    //        fulltag:  <fulltag>
    //        subtype: <subtype>    # optional
    //        hAttr:   <hAttr>      # optional
    //        text:    <text>       # optional
    //        lNodes:  [<node>, ...] # optional
    debug("enter StarbucksMapper.mapNode()", hNode);
    ({str, srcLevel} = hNode);
    hToken = parsetag(str);
    debug('hToken', hToken);
    // --- block tags: script, style, pre, div:markdown
    //     2 possibilities exist:
    //        1. No text on same line, but allow indented text
    //        2. text on same line, but no indented text
    ({tagName, subtype, text} = hToken);
    switch (tagName) {
      case 'script':
        block = hToken.text = this.containedText(hNode, text);
        break;
      case 'style':
        block = hToken.text = this.containedText(hNode, text);
        break;
      case 'pre':
        block = hToken.text = this.containedText(hNode, text);
        break;
      case 'div':
        if (subtype === 'markdown') {
          block = hToken.text = this.containedText(hNode, text);
        }
    }
    debug('block', block);
    debug("return from StarbucksMapper.mapNode()", hToken);
    return hToken;
  }

  // ..........................................................
  handleHereDoc(uobj, block) {
    var str, varName;
    debug("enter handleHereDoc()", uobj, block);
    varName = `$_${this.numVars}`;
    this.numVars += 1;
    str = `${varName} = ${uobj}`;
    debug("add string to vars section", str);
    this.section('vars').add(str);
    debug("return from handleHereDoc()", varName);
    return varName;
  }

  // ..........................................................
  // The various 'visit' methods only add text to sections
  // and ALWAYS return undef
  // ..........................................................
  visit(hNode, hUser, lStack) {
    var beginTag, code, dir, endTag, fname, fullpath, fulltag, hToken, level, source, stmt, subtype, tagName, text, type;
    // --- visit an HTML node
    debug("enter visit()", hNode, hUser, lStack);
    ({
      uobj: hToken,
      level,
      type
    } = hNode);
    assert(type === undef, `type is ${OL(type)}`);
    this.checkToken(hToken);
    ({tagName, subtype, fulltag, text} = hToken);
    beginTag = tag2str(hToken, 'begin');
    endTag = tag2str(hToken, 'end');
    // --- Block tags generate the needed end tags, e.g. </div>
    //     Non-block tags should set hUser.endTag
    switch (fulltag) {
      case 'script':
        this.section('code').add(text);
        break;
      case 'script:startup':
        this.section('startup').add(text);
        break;
      case 'script:onmount':
        this.section('onmount').add(text);
        break;
      case 'script:ondestroy':
        this.section('ondestroy').add(text);
        break;
      case 'style':
        this.section('style').add(text);
        break;
      case 'div:sourcecode':
        code = process.env['cielo.SOURCECODE'];
        this.section('html').add(arrayToBlock([indented(beginTag, level), indented("<pre>", level + 1), indented(code, level + 2), indented("</pre>", level + 1), indented(endTag, level)]));
        break;
      case 'div:markdown':
        code = this.getMarkdownCode(text);
        this.section('html').add(arrayToBlock([indented(beginTag, level), indented(code, level + 1), indented(endTag, level)]));
        break;
      case 'pre':
        this.section('html').add(arrayToBlock([indented(beginTag, level), indented(text, level + 1), indented(endTag, level)]));
        break;
      default:
        // --- Build the contents of the HTML element
        //     and add it to the 'html' section
        this.section('html').add(indented(beginTag, level));
        if (nonEmpty(text)) {
          this.section('html').add(indented(text, level + 1));
        }
        // --- This will cause the end tag to be output in endVisit()
        if (nonEmpty(endTag)) {
          hUser.endTag = endTag;
        }
    }
    // --- Check for svelte components, which need to be imported
    if (tagName.match(/^[A-Z]/)) {
      fname = `${tagName}.svelte`;
      dir = this.hSourceInfo.dir;
      fullpath = pathTo(fname, dir);
      assert(defined(fullpath), `Can't find file ${fname}`);
      source = fullpath.replace(dir, '.');
      stmt = `import {${tagName}} from '${source}';`;
      this.section('import').add(stmt);
    }
    debug("return undef from visit()");
    return undef;
  }

  // ..........................................................
  endVisit(hNode, hUser, lStack) {
    var hToken, level, type;
    debug("enter endVisit()", hNode, hUser, lStack);
    ({
      uobj: hToken,
      level,
      type
    } = hNode);
    assert(type === undef, `type is ${OL(type)}`);
    if (nonEmpty(hUser.endTag)) {
      this.section('html').add(indented(hUser.endTag, level));
    }
    debug("return undef from endVisit()");
    return undef;
  }

  // ..........................................................
  visitCmd(hNode) {
    var argstr, cmd, level, lineNum, srcLevel, uobj;
    debug("enter StarbucksMapper.visitCmd()", hNode);
    ({uobj, srcLevel, level, lineNum} = hNode);
    ({cmd, argstr} = uobj);
    // --- NOTE: build-in commands like #define, #ifdef, etc.
    //           are handled during the mapping phase and
    //           should not appear here
    assert(lMyCmds.includes(cmd), `unknown command ${OL(cmd)}`);
    switch (cmd) {
      case 'starbucks':
        assert(lineNum === 1, `lineNum is ${OL(lineNum)}`);
        assert(srcLevel === 0, `srcLevel is ${OL(srcLevel)}`);
        this.parseHeader(argstr);
        this.headerFound = true; // checked in endWalk()
        break;
      case 'if':
        this.section('html').add(indented(`{#if ${argstr}}`, level));
        break;
      case 'else':
        assert(isEmpty(argstr), "else with cond");
        this.section('html').add(indented("{:else}", level));
        break;
      case 'elsif':
        assert(nonEmpty(argstr), "elsif with no cond");
        this.section('html').add(indented(`{:else if ${argstr}}`, level));
        break;
      default:
        super.visitCmd(hNode);
    }
    debug("return undef from StarbucksMapper.visitCmd()");
    return undef;
  }

  // ..........................................................
  endVisitCmd(hNode) {
    var cmd, level, lineNum, srcLevel;
    debug("enter StarbucksMapper.endVisitCmd()", hNode);
    ({cmd, srcLevel, level, lineNum} = hNode);
    switch (cmd) {
      case 'if':
        this.section('html').add(indented("{/if}", level));
    }
    debug("return undef from StarbucksMapper.endVisitCmd()");
    return undef;
  }

  // ..........................................................
  endWalk() {
    assert(this.headerFound, "missing #starbucks header");
    return undef;
  }

  // ..........................................................
  finalizeBlock(block) {
    var result;
    debug("enter StarbucksMapper.finalizeBlock()");
    // --- everything added should have been added to the section map
    //     the visit methods should always return undef in starbucks
    assert(isEmpty(block), "block not empty");
    // --- NOTE: The following MUST use "fat arrow" syntax
    //           so that it gets the correct "this" object
    debug('scriptType', this.scriptType);
    debug('sectMap', this.sectMap);
    result = this.sectMap.getBlock(undef, {
      Script: (block) => {
        var code, mainCode, startupCode;
        debug("enter Script", this.scriptType);
        // --- We don't want <script>..</script> if block is empty
        if (isEmpty(block)) {
          debug("return from Script", '');
          return '';
        }
        // --- This might return CieloScript, CoffeeScript or JavaScript
        code = this.getScriptCode(block);
        debug("SCRIPT", code);
        if (this.scriptType === 'js') {
          [startupCode, mainCode] = debar(code, this.hSourceInfo.filename);
          result = arrayToBlock([elem('script', undef, startupCode, this.oneIndent), elem('script', undef, mainCode, this.oneIndent)]);
        } else {
          result = elem('script', undef, code, this.oneIndent);
        }
        debug("return from Script", result);
        return result;
      },
      style: (block) => {
        var code;
        // --- We don't want <style>..</style> if block is empty
        if (isEmpty(block)) {
          return '';
        }
        // --- This might return SASS or CSS
        code = this.getStyleCode(block);
        return elem('style', undef, code, this.oneIndent);
      }
    });
    debug("return from StarbucksMapper.finalizeBlock()", result);
    return result;
  }

  // ..........................................................
  // ..........................................................
  section(name) {
    return this.sectMap.section(name);
  }

  // ..........................................................
  checkToken(hToken) {
    var subtype, tagName;
    assert(hToken.type === 'tag', `hToken is ${OL(hToken)}`);
    ({tagName, subtype} = hToken);
    switch (tagName) {
      case 'script':
        if (nonEmpty(subtype)) {
          assert(['startup', 'onmount', 'ondestroy'].includes(subtype), `Invalid subtype ${subtype} in <script> section`);
        }
        break;
      case 'div':
        if (nonEmpty(subtype)) {
          assert(['markdown', 'sourcecode'].includes(subtype), `Invalid subtype ${subtype} in <div> section`);
        }
    }
  }

  // ..........................................................
  getScriptCode(block) {
    var result;
    debug("enter getScriptCode()", block);
    assert(defined(block), "block is undef");
    debug("scriptType", this.scriptType);
    switch (this.scriptType) {
      case 'cielo':
        result = block;
        break;
      case 'coffee':
        result = map(this.source, block, CieloToCoffeeMapper);
        break;
      case 'js':
        result = map(this.source, block, CieloToJSMapper);
        break;
      default:
        croak(`Bad script type ${OL(this.scriptType)}`);
    }
    debug("return from getScriptCode()", result);
    return result;
  }

  // ..........................................................
  getStyleCode(block) {
    var result;
    debug("enter getStyleCode()", block);
    debug("styleType", this.styleType);
    switch (this.styleType) {
      case 'css':
        result = sassify(block, this.hSourceInfo.fullpath);
        break;
      case 'sass':
        result = block;
        break;
      default:
        croak(`Bad style type ${OL(this.styleType)}`);
    }
    debug("return from getStyleCode()", result);
    return result;
  }

  // ..........................................................
  getMarkdownCode(block) {
    switch (this.markdownType) {
      case 'html':
        return markdownify(block);
      case 'markdown':
        return block;
      default:
        return croak(`Bad markdown type ${OL(this.markdownType)}`);
    }
  }

  // ..........................................................
  parseHeader(argstr) {
    var _, i, j, k, kind, lMatches, len, len1, len2, name, opt, optionstr, parm, parmStr, ref, ref1, ref2, value;
    lMatches = argstr.match(/^(webpage|component)?\s*(?:\(([^\)]*)\)\s*)?(.*)$/); // parameters
    // open paren
    // anything except ) - parameters to component
    // close paren
    // options
    assert(lMatches, `Invalid header: '#starbucks ${argstr}'`);
    [_, kind, parmStr, optionstr] = lMatches;
    // --- if debugging, turn it on before calling debug()
    if (isString(optionstr) && optionstr.match(/\bdebug\b/)) {
      setDebugging(true);
    }
    debug("Parsing #starbucks header line");
    if (defined(kind)) {
      if (defined(this.kind)) {
        assert(kind === this.kind, "$kind, should be $@kind");
      } else {
        this.kind = kind;
      }
    } else {
      assert(defined(this.kind), "No kind is defined");
    }
    if (nonEmpty(parmStr)) {
      this.lParms = parmStr.trim().split(/\s*,\s*/);
      assert(isUniqueList(this.lParms), "parameters not unique");
      switch (this.kind) {
        case 'webpage':
          this.section('startup').add(`export load = ({page}) ->
	return {props: {${lParms.join(',')}}}`);
          break;
        case 'component':
          ref = this.lParms;
          for (i = 0, len = ref.length; i < len; i++) {
            parm = ref[i];
            this.section('export').add(`export ${parm} = undef`);
          }
      }
    }
    if (nonEmpty(optionstr)) {
      ref1 = optionstr.trim().split(/\s+/);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        opt = ref1[j];
        [name, value] = opt.split(/=/, 2);
        debug(`OPTION ${name} = '${value}'`);
        switch (name) {
          case 'debug':
            pass; // already done
            break;
          case 'script':
            assert(['cielo', 'coffee', 'js'].includes(value), "script must be 'cielo', 'coffee' or 'js'");
            this.scriptType = value;
            break;
          case 'style':
            assert(['css', 'sass'].includes(value), "style must be 'css' or 'sass'");
            this.styleType = value;
            break;
          case 'markdown':
            assert(['html', 'markdown'].includes(value), "markdown must be 'html' or 'markdown'");
            this.markdownType = value;
            break;
          case 'store':
          case 'stores':
            ref2 = value.split(/\,/);
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              name = ref2[k];
              this.lStores.push(name);
            }
            break;
          case 'keyhandler':
            this.keyhandler = value;
            break;
          default:
            croak(`Unknown option: ${name}`);
        }
      }
    }
    if (notdefined(this.scriptType)) {
      this.scriptType = 'js';
    }
    if (notdefined(this.styleType)) {
      this.styleType = 'css';
    }
    if (notdefined(this.markdownType)) {
      this.markdownType = 'html';
    }
  }

};

// ---------------------------------------------------------------------------
